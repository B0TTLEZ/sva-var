#pragma once
#include <string>
#include <set>
#include <map>
#include <vector>

// 改进的条件表达式节点
struct ConditionExpression {
    std::string expression;  // 完整的表达式文本
    std::set<std::string> involvedSignals;  // 涉及的所有信号
    std::set<std::string> involvedParameters;   // 编译期参数（parameter, localparam, enum 常量等）
    
    bool operator<(const ConditionExpression& other) const {
        if (expression != other.expression) 
            return expression < other.expression;
        if (involvedSignals != other.involvedSignals)
            return involvedSignals < other.involvedSignals;
        return involvedParameters < other.involvedParameters; // ←← 新增比较
    }
};

struct ConditionClause {
    ConditionExpression expr;  // 条件表达式
    bool polarity;            // true: 原表达式, false: 取反
    
    bool operator<(const ConditionClause& other) const {
        if (expr < other.expr) return true;
        if (other.expr < expr) return false;
        return polarity < other.polarity;
    }
};

using ConditionPath = std::set<ConditionClause>;

struct AssignmentInfo {
    ConditionPath path;
    std::set<std::string> drivingSignals;
    std::string file;
    int line = 0;
    std::string type = "direct";
    std::string logicType = "unknown";  // 新增："sequential" 或 "combinational"
    int conditionDepth = 0;             // 新增：条件嵌套深度

    bool operator<(const AssignmentInfo& other) const {
        if (path < other.path) return true;
        if (other.path < path) return false;
        if (drivingSignals < other.drivingSignals) return true;
        if (other.drivingSignals < drivingSignals) return false;
        if (file != other.file) return file < other.file;
        if (line != other.line) return line < other.line;
        if (type != other.type) return type < other.type;
        if (logicType != other.logicType) return logicType < other.logicType;
        return conditionDepth < other.conditionDepth;
    }
};

struct VariableInfo {
    std::string fullName;
    std::string type;
    std::string fileName;
    int line = 0;
    std::string direction;
    size_t bitWidth = 0;
    std::set<AssignmentInfo> assignments;
    std::set<std::string> fanOut;
    // 新增：计算得出的属性
    int assignmentCount = 0;            // 赋值次数
    bool drivesOutput = false;          // 是否驱动输出
    bool isControlVariable = false;     // 是否是控制变量
};#pragma once
#include "DataModel.h"
#include "slang/ast/ASTVisitor.h"
#include "slang/ast/statements/ConditionalStatements.h"
#include "slang/ast/symbols/PortSymbols.h"
#include "slang/ast/symbols/VariableSymbols.h"
#include "slang/ast/symbols/InstanceSymbols.h"

using AnalysisResultMap = std::map<std::string, VariableInfo>;

// 前置声明辅助函数
bool isEnumConstant(const slang::ast::Symbol& symbol);

class DependencyVisitor : public slang::ast::ASTVisitor<DependencyVisitor, true, true> {
public:
    DependencyVisitor();

    // 简化模板处理
    template<typename T>
    void handle(const T& node) {
        visitDefault(node);
    }
    
    // 显式声明需要处理的节点类型
    void handle(const slang::ast::VariableSymbol& symbol);
    void handle(const slang::ast::PortSymbol& symbol);
    void handle(const slang::ast::AssignmentExpression& expr);
    void handle(const slang::ast::ConditionalStatement& stmt);
    void handle(const slang::ast::CaseStatement& stmt);
    void handle(const slang::ast::InstanceSymbol& symbol);
    void handle(const slang::ast::ProceduralBlockSymbol& symbol);
    void handle(const slang::ast::InstanceBodySymbol& symbol);
    void postProcess();

    const AnalysisResultMap& getResults() const { return results; }

private:
    VariableInfo& getOrAddVariable(const slang::ast::Symbol& symbol);
    
    // 新增方法声明
    void handleMemberAssignment(const slang::ast::AssignmentExpression& expr, 
                               const slang::ast::MemberAccessExpression& memberExpr);
    VariableInfo& getOrAddVariableByName(const std::string& fullName);
    std::string getFullMemberPath(const slang::ast::Expression& expr);
    
    std::string extractCaseItemExpression(const slang::ast::Expression& caseExpr, const slang::ast::CaseStatement::ItemGroup& item);
    std::vector<ConditionPath> buildCasePaths(const slang::ast::CaseStatement& stmt, const ConditionPath& parentPath);
    bool isControlVariable(const std::string& varName);
    
    const slang::ast::ProceduralBlockSymbol* currentProcBlock = nullptr;  
    std::vector<ConditionPath> pathStack;
    AnalysisResultMap results;
};#include "DependencyVisitor.h"
#include "slang/ast/Compilation.h"
#include "slang/ast/expressions/OperatorExpressions.h"
#include "slang/ast/expressions/MiscExpressions.h"
#include "slang/ast/expressions/SelectExpressions.h"
#include "slang/ast/symbols/PortSymbols.h"
#include "slang/ast/symbols/InstanceSymbols.h"
#include "slang/ast/symbols/VariableSymbols.h"
#include "slang/ast/types/Type.h"
#include "slang/ast/types/AllTypes.h"
#include "slang/text/SourceManager.h"
#include <sstream>
#include <iostream>

// ============================================================================
// 辅助函数
// ============================================================================

// 检查是否为编译时常量
bool isCompileTimeConstant(const slang::ast::Symbol& symbol) {
    return symbol.kind == slang::ast::SymbolKind::EnumValue ||
           symbol.kind == slang::ast::SymbolKind::Parameter; // localparam 也是 Parameter
}

// 自增操作检测
bool isIncrementOperation(const slang::ast::Expression& expr, const slang::ast::Symbol& lhsSymbol) {
    if (const auto* binaryExpr = expr.as_if<slang::ast::BinaryExpression>()) {
        if (binaryExpr->op == slang::ast::BinaryOperator::Add) {
            // 检查左操作数是否是同一个信号
            if (const auto* leftValue = binaryExpr->left().as_if<slang::ast::NamedValueExpression>()) {
                if (&leftValue->symbol == &lhsSymbol) {
                    // 检查右操作数是否是常量
                    if (binaryExpr->right().as_if<slang::ast::IntegerLiteral>()) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// 枚举常量检测
bool isEnumConstant(const slang::ast::Symbol& symbol) {
    return symbol.kind == slang::ast::SymbolKind::EnumValue;
}

// 端口方向转换
static std::string directionToString(slang::ast::ArgumentDirection dir) {
    switch (dir) {
        case slang::ast::ArgumentDirection::In: return "input";
        case slang::ast::ArgumentDirection::Out: return "output";
        case slang::ast::ArgumentDirection::InOut: return "inout";
        default: return "unknown";
    }
}

// ============================================================================
// DataSignalVisitor - 提取数据信号，过滤枚举常量
// ============================================================================

class DataSignalVisitor : public slang::ast::ASTVisitor<DataSignalVisitor, true, true> {
public:
    template<typename T> void handle(const T& node) { visitDefault(node); }

    void handle(const slang::ast::NamedValueExpression& expr) {
        const slang::ast::Symbol* symbol = &expr.symbol;
        if (symbol && !symbol->isType()) {
            if (!isCompileTimeConstant(*symbol)) {
                std::string signalName = symbol->getHierarchicalPath();
                signals.insert(signalName);
            }
        }
    }

    void handle(const slang::ast::MemberAccessExpression& expr) {
        std::string fullPath = getFullMemberPath(expr);
        if (!fullPath.empty()) {
            // std::cout << "[DEBUG] DataSignalVisitor found member: " << fullPath << std::endl;
            signals.insert(fullPath);
            
            // // 同时记录父级
            // std::string parentPath = getFullMemberPath(expr.value());
            // if (!parentPath.empty()) {
            //     std::cout << "[DEBUG] DataSignalVisitor found parent: " << parentPath << std::endl;
            //     signals.insert(parentPath);
            // }
        }
    }

    std::string getFullMemberPath(const slang::ast::Expression& expr) {
        if (const auto* namedExpr = expr.as_if<slang::ast::NamedValueExpression>()) {
            return std::string(namedExpr->symbol.getHierarchicalPath());
        }
        if (const auto* memberExpr = expr.as_if<slang::ast::MemberAccessExpression>()) {
            std::string base = getFullMemberPath(memberExpr->value());
            if (!base.empty()) {
                return base + "." + std::string(memberExpr->member.name);
            }
        }
        if (const auto* selectExpr = expr.as_if<slang::ast::ElementSelectExpression>()) {
            std::string base = getFullMemberPath(selectExpr->value());
            if (!base.empty()) {
                return base + "[*]";
            }
        }
        return "";
    }

    std::set<std::string> signals;
};

// ============================================================================
// ConditionClauseVisitor - 分析条件子句，过滤枚举常量
// ============================================================================

class ConditionClauseVisitor : public slang::ast::ASTVisitor<ConditionClauseVisitor, true, true> {
public:
    template<typename T> void handle(const T& node) { 
        visitDefault(node); 
    }

    void handle(const slang::ast::NamedValueExpression& expr) {
        const slang::ast::Symbol* symbol = &expr.symbol;
        if (!symbol || symbol->isType()) return;

        std::string fullName = symbol->getHierarchicalPath();
        bool isParamOrEnum = isCompileTimeConstant(*symbol);

        if (!currentExpression.empty()) {
            currentExpression += " ";
        }
        currentExpression += fullName;

        if (isParamOrEnum) {
            involvedParameters.insert(fullName);
        } else {
            involvedSignals.insert(fullName);
        }
    }

    void handle(const slang::ast::MemberAccessExpression& expr) {
        std::string fullPath = getFullMemberPath(expr);
        if (!fullPath.empty()) {
            bool isParamOrEnum = false;
            if (const slang::ast::Symbol* memberSym = expr.getSymbolReference()) {
                isParamOrEnum = isCompileTimeConstant(*memberSym);
            }
            
            if (!currentExpression.empty()) {
                currentExpression += " ";
            }
            currentExpression += fullPath;
            
            if (isParamOrEnum) {
                involvedParameters.insert(fullPath);
            } else {
                involvedSignals.insert(fullPath);
            }
            
            // 同时记录父级结构体/联合体的依赖
            std::string parentPath = getFullMemberPath(expr.value());
            if (!parentPath.empty()) {
                bool parentIsParamOrEnum = false;
                if (const auto* namedExpr = expr.value().as_if<slang::ast::NamedValueExpression>()) {
                    parentIsParamOrEnum = isCompileTimeConstant(namedExpr->symbol);
                }
                
                if (parentIsParamOrEnum) {
                    involvedParameters.insert(parentPath);
                } else {
                    involvedSignals.insert(parentPath);
                }
            }
        } else {
            visitDefault(expr);
        }
    }

    void handle(const slang::ast::BinaryExpression& expr) {
        expr.left().visit(*this);
        
        std::string opStr;
        switch (expr.op) {
            case slang::ast::BinaryOperator::Equality: opStr = " == "; break;
            case slang::ast::BinaryOperator::Inequality: opStr = " != "; break;
            case slang::ast::BinaryOperator::LogicalAnd: opStr = " && "; break;
            case slang::ast::BinaryOperator::LogicalOr: opStr = " || "; break;
            case slang::ast::BinaryOperator::GreaterThanEqual: opStr = " >= "; break;
            case slang::ast::BinaryOperator::GreaterThan: opStr = " > "; break;
            case slang::ast::BinaryOperator::LessThanEqual: opStr = " <= "; break;
            case slang::ast::BinaryOperator::LessThan: opStr = " < "; break;
            default: opStr = " op "; break;
        }
        currentExpression += opStr;
        
        expr.right().visit(*this);
    }

    void handle(const slang::ast::UnaryExpression& expr) {
        std::string opStr;
        switch (expr.op) {
            case slang::ast::UnaryOperator::LogicalNot: opStr = "!"; break;
            case slang::ast::UnaryOperator::BitwiseAnd: opStr = "&"; break;
            case slang::ast::UnaryOperator::BitwiseOr: opStr = "|"; break;
            case slang::ast::UnaryOperator::BitwiseXor: opStr = "^"; break;
            default: opStr = "unary_op "; break;
        }
        currentExpression += opStr;
        
        expr.operand().visit(*this);
    }

    void handle(const slang::ast::IntegerLiteral& literal) {
        if (!currentExpression.empty()) {
            currentExpression += " ";
        }
        currentExpression += literal.getValue().toString();
    }

    void handle(const slang::ast::ElementSelectExpression& expr) {
        expr.value().visit(*this);
        currentExpression += "[";
        expr.selector().visit(*this);
        currentExpression += "]";
    }

    void handle(const slang::ast::RangeSelectExpression& expr) {
        expr.value().visit(*this);
        currentExpression += "[";
        expr.left().visit(*this);
        currentExpression += ":";
        expr.right().visit(*this);
        currentExpression += "]";
    }

    std::string getExpressionString() const {
        return currentExpression;
    }

    std::set<std::string> getInvolvedSignals() const {
        return involvedSignals;
    }

    std::set<std::string> getInvolvedParameters() const {
        return involvedParameters;
    }

    void reset() {
        currentExpression.clear();
        involvedSignals.clear();
        involvedParameters.clear();
    }

    std::string getFullMemberPath(const slang::ast::Expression& expr) {
        if (const auto* namedExpr = expr.as_if<slang::ast::NamedValueExpression>()) {
            return std::string(namedExpr->symbol.getHierarchicalPath());
        }
        if (const auto* memberExpr = expr.as_if<slang::ast::MemberAccessExpression>()) {
            std::string base = getFullMemberPath(memberExpr->value());
            if (!base.empty()) {
                return base + "." + std::string(memberExpr->member.name);
            }
        }
        if (const auto* selectExpr = expr.as_if<slang::ast::ElementSelectExpression>()) {
            std::string base = getFullMemberPath(selectExpr->value());
            if (!base.empty()) {
                return base + "[*]";
            }
        }
        return "";
    }

private:
    std::string currentExpression;
    std::set<std::string> involvedSignals;
    std::set<std::string> involvedParameters;
};

// ============================================================================
// CaseItemExpressionVisitor - 处理 case 项表达式
// ============================================================================

class CaseItemExpressionVisitor : public slang::ast::ASTVisitor<CaseItemExpressionVisitor, true, true> {
public:
    template<typename T> void handle(const T& node) { 
        visitDefault(node); 
    }

    void handle(const slang::ast::NamedValueExpression& expr) {
        const slang::ast::Symbol* symbol = &expr.symbol;
        if (symbol && !symbol->isType()) {
            std::string signalName = symbol->getHierarchicalPath();
            if (!currentExpression.empty()) {
                currentExpression += " ";
            }
            currentExpression += signalName;
        }
    }

    void handle(const slang::ast::IntegerLiteral& literal) {
        if (!currentExpression.empty()) {
            currentExpression += " ";
        }
        currentExpression += literal.getValue().toString();
    }

    void handle(const slang::ast::BinaryExpression& expr) {
        if (expr.op == slang::ast::BinaryOperator::LogicalOr) {
            expr.left().visit(*this);
            currentExpression += " || ";
            expr.right().visit(*this);
        } else {
            visitDefault(expr);
        }
    }

    void handle(const slang::ast::UnaryExpression& expr) {
        if (expr.op == slang::ast::UnaryOperator::LogicalNot) {
            currentExpression += "!";
            expr.operand().visit(*this);
        } else {
            visitDefault(expr);
        }
    }

    std::string getExpressionString() const {
        return currentExpression;
    }

    void reset() {
        currentExpression.clear();
    }

private:
    std::string currentExpression;
};

// ============================================================================
// DependencyVisitor 主实现
// ============================================================================

DependencyVisitor::DependencyVisitor() {
    pathStack.push_back({});
}

// 获取或创建变量信息
VariableInfo& DependencyVisitor::getOrAddVariable(const slang::ast::Symbol& symbol) {  
    std::string path = symbol.getHierarchicalPath();  
    if (results.find(path) == results.end()) {  
        VariableInfo info;  
        info.fullName = path;  

        if (const auto* portSymbol = symbol.as_if<slang::ast::PortSymbol>()) {  
            info.direction = directionToString(portSymbol->direction);  
            if (portSymbol->internalSymbol) {  
                const auto* internalValue = portSymbol->internalSymbol->as_if<slang::ast::ValueSymbol>();  
                if (internalValue) {  
                    const slang::ast::Type& type = internalValue->getType();  
                    info.type = type.toString();  
                    info.bitWidth = type.getBitWidth();  
                }  
            }  
        } else if (const auto* valueSymbol = symbol.as_if<slang::ast::ValueSymbol>()) {  
            const slang::ast::Type& type = valueSymbol->getType();  
            info.type = type.toString();  
            info.bitWidth = type.getBitWidth();  
        }  

        const slang::ast::Scope* scope = symbol.getParentScope();  
        if (scope) {  
            auto& comp = scope->getCompilation();  
            auto* sm = comp.getSourceManager();  
            if (sm && symbol.location) {  
                info.fileName = std::string(sm->getFileName(symbol.location));  
                info.line = sm->getLineNumber(symbol.location);  
            }  
        }  
        results[path] = info;  
    }  
    return results.at(path);  
}

// 通过名称获取或创建变量信息
VariableInfo& DependencyVisitor::getOrAddVariableByName(const std::string& fullName) {
    if (results.find(fullName) == results.end()) {
        VariableInfo info;
        info.fullName = fullName;
        results[fullName] = info;
    }
    return results.at(fullName);
}

// 获取完整的成员访问路径
std::string DependencyVisitor::getFullMemberPath(const slang::ast::Expression& expr) {
    if (const auto* namedExpr = expr.as_if<slang::ast::NamedValueExpression>()) {
        return std::string(namedExpr->symbol.getHierarchicalPath());
    }
    if (const auto* memberExpr = expr.as_if<slang::ast::MemberAccessExpression>()) {
        std::string base = getFullMemberPath(memberExpr->value());
        if (!base.empty()) {
            // 获取成员名称
            std::string memberName = std::string(memberExpr->member.name);
            return base + "." + memberName;
        }
    }
    return "";
}

// 处理成员访问赋值
// 处理成员访问赋值
void DependencyVisitor::handleMemberAssignment(const slang::ast::AssignmentExpression& expr, 
                                              const slang::ast::MemberAccessExpression& memberExpr) {
    // std::cout << "[DEBUG] handleMemberAssignment called!" << std::endl;
    
    // 获取完整的成员路径
    std::string fullMemberPath = getFullMemberPath(memberExpr);
    // std::cout << "[DEBUG] Full member path: " << fullMemberPath << std::endl;
    
    if (fullMemberPath.empty()) {
        // std::cout << "[DEBUG] Empty member path, skipping" << std::endl;
        visitDefault(expr);
        return;
    }
    
    // 为成员创建变量信息
    VariableInfo& memberInfo = getOrAddVariableByName(fullMemberPath);
    // std::cout << "[DEBUG] Created variable info for: " << fullMemberPath << std::endl;
    
    // 分析右侧表达式
    DataSignalVisitor rhsVisitor;
    expr.right().visit(rhsVisitor);
    
    // std::cout << "[DEBUG] RHS signals: ";
    // for (const auto& sig : rhsVisitor.signals) {
    //     std::cout << sig << " ";
    // }
    // std::cout << std::endl;
    
    // 创建赋值记录
    AssignmentInfo assignInfo;
    assignInfo.path = pathStack.back();
    assignInfo.drivingSignals = rhsVisitor.signals;
    assignInfo.type = "member_assignment";
    assignInfo.logicType = "combinational";
    assignInfo.conditionDepth = pathStack.size() - 1;
    
    memberInfo.assignments.insert(assignInfo);
    // std::cout << "[DEBUG] Added assignment to member: " << fullMemberPath << std::endl;
    
    // // 同时为父级结构体/联合体创建赋值记录
    // std::string parentPath = getFullMemberPath(memberExpr.value());
    // if (!parentPath.empty()) {
    //     std::cout << "[DEBUG] Parent path: " << parentPath << std::endl;
        
    //     VariableInfo& parentInfo = getOrAddVariableByName(parentPath);
        
    //     AssignmentInfo parentAssignInfo;
    //     parentAssignInfo.path = pathStack.back();
    //     parentAssignInfo.drivingSignals = {fullMemberPath};
    //     parentAssignInfo.type = "structural_parent";
    //     parentAssignInfo.logicType = "combinational";
    //     parentAssignInfo.conditionDepth = pathStack.size() - 1;
        
    //     parentInfo.assignments.insert(parentAssignInfo);
    //     std::cout << "[DEBUG] Added parent assignment to: " << parentPath << std::endl;
    // }
    
    visitDefault(expr);
}

// 提取 case 项表达式
std::string DependencyVisitor::extractCaseItemExpression(const slang::ast::Expression& caseExpr, 
                                                        const slang::ast::CaseStatement::ItemGroup& item) {
    CaseItemExpressionVisitor visitor;
    
    if (item.expressions.empty()) {
        return "default";
    }
    
    // 获取case表达式的字符串表示
    ConditionClauseVisitor caseExprVisitor;
    caseExpr.visit(caseExprVisitor);
    std::string caseExprStr = caseExprVisitor.getExpressionString();
    
    // 处理多个表达式（OR关系）
    std::string result;
    for (size_t i = 0; i < item.expressions.size(); ++i) {
        if (i > 0) {
            result += " || ";
        }
        visitor.reset();
        item.expressions[i]->visit(visitor);
        result += caseExprStr + " == " + visitor.getExpressionString();
    }
    
    return result;
}

// 构建 case 路径
std::vector<ConditionPath> DependencyVisitor::buildCasePaths(const slang::ast::CaseStatement& stmt, 
                                                            const ConditionPath& parentPath) {
    std::vector<ConditionPath> casePaths;
    
    ConditionClauseVisitor caseExprVisitor;
    stmt.expr.visit(caseExprVisitor);
    
    ConditionExpression caseExpr;
    caseExpr.expression = caseExprVisitor.getExpressionString();
    caseExpr.involvedSignals = caseExprVisitor.getInvolvedSignals();
    caseExpr.involvedParameters = caseExprVisitor.getInvolvedParameters();
    bool hasDefault = false;
    
    // 处理每个case项
    for (const auto& item : stmt.items) {
        std::string itemExpression = extractCaseItemExpression(stmt.expr, item);
        
        if (itemExpression == "default") {
            hasDefault = true;
            continue;
        }
        
        ConditionExpression fullCondition;
        fullCondition.expression = itemExpression;
        fullCondition.involvedSignals = caseExpr.involvedSignals;
        
        // 添加item表达式中涉及的信号
        for (const auto& expr : item.expressions) {
            ConditionClauseVisitor itemVisitor;
            expr->visit(itemVisitor);
            auto signals = itemVisitor.getInvolvedSignals();
            fullCondition.involvedSignals.insert(signals.begin(), signals.end());
        }
        
        ConditionClause conditionClause;
        conditionClause.expr = fullCondition;
        conditionClause.polarity = true;
        
        ConditionPath itemPath = parentPath;
        itemPath.insert(conditionClause);
        casePaths.push_back(itemPath);
    }
    
    // 处理default情况
    if (hasDefault || stmt.defaultCase) {
        ConditionPath defaultPath = parentPath;
        
        for (const auto& item : stmt.items) {
            std::string itemExpression = extractCaseItemExpression(stmt.expr, item);
            if (itemExpression == "default") continue;
            
            ConditionExpression fullCondition;
            fullCondition.expression = itemExpression;
            fullCondition.involvedSignals = caseExpr.involvedSignals;
            
            for (const auto& expr : item.expressions) {
                ConditionClauseVisitor itemVisitor;
                expr->visit(itemVisitor);
                auto signals = itemVisitor.getInvolvedSignals();
                fullCondition.involvedSignals.insert(signals.begin(), signals.end());
            }
            
            ConditionClause conditionClause;
            conditionClause.expr = fullCondition;
            conditionClause.polarity = false;
            
            defaultPath.insert(conditionClause);
        }
        
        casePaths.push_back(defaultPath);
    }
    
    return casePaths;
}

// ============================================================================
// 主要处理函数
// ============================================================================

void DependencyVisitor::handle(const slang::ast::VariableSymbol& symbol) {
    getOrAddVariable(symbol);
    visitDefault(symbol);
}

void DependencyVisitor::handle(const slang::ast::PortSymbol& symbol) {
    getOrAddVariable(symbol);
    visitDefault(symbol);
}

void DependencyVisitor::handle(const slang::ast::AssignmentExpression& expr) {
    if (!expr.syntax) {  
        return;  
    }  
    std::cout << "[DEBUG] Processing assignment expression:"<<expr.left().getSymbolReference()->getHierarchicalPath() << std::endl;
    
    // 首先检查是否为成员访问表达式
    if (const auto* memberExpr = expr.left().as_if<slang::ast::MemberAccessExpression>()) {
        // std::cout << "[DEBUG] Found member access on LHS, handling member assignment" << std::endl;
        handleMemberAssignment(expr, *memberExpr);
        return;
    }
    
    // 如果不是成员访问，再检查简单符号
    const slang::ast::Symbol* lhsSymbol = expr.left().getSymbolReference();
    if (!lhsSymbol) {
        visitDefault(expr);
        return;
    }
    
    // 原有的简单符号处理逻辑
    std::string lhsName = lhsSymbol->getHierarchicalPath();
    // std::cout << "[DEBUG] Simple assignment to: " << lhsName << std::endl;
    
    VariableInfo& lhsInfo = getOrAddVariable(*lhsSymbol);
        
    bool isIncrement = isIncrementOperation(expr.right(), *lhsSymbol);

    DataSignalVisitor rhsVisitor;
    if (!isIncrement) {
        expr.right().visit(rhsVisitor);
    }

    AssignmentInfo assignInfo;
    assignInfo.path = pathStack.back();
    assignInfo.drivingSignals = rhsVisitor.signals;
    if (isIncrement) {
        assignInfo.type = "increment";
    } else if (rhsVisitor.signals.empty()) {
        std::cout << "[DEBUG] Assignment is a constant assignment for" <<expr.left().getSymbolReference()->getHierarchicalPath() << std::endl;
        assignInfo.type = "constant";
    } else {
        assignInfo.type = "direct";
    }
    
    // 时序逻辑检测
    if (currentProcBlock) {  
        if (currentProcBlock->procedureKind == slang::ast::ProceduralBlockKind::AlwaysFF) {  
            assignInfo.logicType = "sequential";  
        }   
        else if (currentProcBlock->procedureKind == slang::ast::ProceduralBlockKind::AlwaysComb ||  
                 currentProcBlock->procedureKind == slang::ast::ProceduralBlockKind::AlwaysLatch) {  
            assignInfo.logicType = "combinational";  
        }  
        else if (currentProcBlock->procedureKind == slang::ast::ProceduralBlockKind::Always) {  
            if (expr.isNonBlocking()) {  
                assignInfo.logicType = "sequential";  
            } else {  
                assignInfo.logicType = "combinational";  
            }  
        }  
        else if (currentProcBlock->procedureKind == slang::ast::ProceduralBlockKind::Initial ||  
                 currentProcBlock->procedureKind == slang::ast::ProceduralBlockKind::Final) {  
            assignInfo.logicType = "initialization";  
        }  
        else {  
            assignInfo.logicType = "combinational";  
        }  
    } else {  
        assignInfo.logicType = "combinational";  
    }  
    
    assignInfo.conditionDepth = pathStack.size() - 1;

    const slang::ast::Scope* scope = lhsSymbol->getParentScope();
    if (scope) {
        auto& comp = scope->getCompilation();
        auto* sm = comp.getSourceManager();
        if (sm && expr.sourceRange.start()) {
            assignInfo.file = std::string(sm->getFileName(expr.sourceRange.start()));
            assignInfo.line = sm->getLineNumber(expr.sourceRange.start());
        }
    }
    lhsInfo.assignments.insert(assignInfo);
    
    visitDefault(expr);
}

void DependencyVisitor::handle(const slang::ast::ConditionalStatement& stmt) {
    ConditionPath parentPath = pathStack.back();
    
    for (size_t i = 0; i < stmt.conditions.size(); ++i) {
        const auto& cond = stmt.conditions[i];
        
        ConditionClauseVisitor clauseVisitor;
        cond.expr->visit(clauseVisitor);

        ConditionExpression condExpr;
        condExpr.expression = clauseVisitor.getExpressionString();
        condExpr.involvedSignals = clauseVisitor.getInvolvedSignals();
        condExpr.involvedParameters = clauseVisitor.getInvolvedParameters();
        ConditionClause trueClause;
        trueClause.expr = condExpr;
        trueClause.polarity = true;

        ConditionPath truePath = parentPath;
        truePath.insert(trueClause);
        pathStack.push_back(truePath);
        
        stmt.ifTrue.visit(*this);
        pathStack.pop_back();

        ConditionClause falseClause;
        falseClause.expr = condExpr;
        falseClause.polarity = false;
        parentPath.insert(falseClause);
    }

    if (stmt.ifFalse) {
        pathStack.push_back(parentPath);
        stmt.ifFalse->visit(*this);
        pathStack.pop_back();
    }
}

void DependencyVisitor::handle(const slang::ast::CaseStatement& stmt) {
    ConditionPath parentPath = pathStack.back();
    
    std::vector<ConditionPath> casePaths = buildCasePaths(stmt, parentPath);
    
    size_t pathIndex = 0;
    for (const auto& item : stmt.items) {
        if (pathIndex < casePaths.size()) {
            pathStack.push_back(casePaths[pathIndex]);
            if (item.stmt) {
                item.stmt->visit(*this);
            }
            pathStack.pop_back();
            pathIndex++;
        }
    }
    
    if (stmt.defaultCase && pathIndex < casePaths.size()) {
        pathStack.push_back(casePaths[pathIndex]);
        stmt.defaultCase->visit(*this);
        pathStack.pop_back();
    }
}

void DependencyVisitor::handle(const slang::ast::InstanceBodySymbol& symbol) {  
    // 第一遍:先收集所有变量、wire 和端口  
    for (auto& member : symbol.members()) {  
        if (member.kind == slang::ast::SymbolKind::Variable ||  
            member.kind == slang::ast::SymbolKind::Net ||  
            member.kind == slang::ast::SymbolKind::Port) {  
            getOrAddVariable(member);  
        }  
    }  
      
    // 第二遍:正常遍历(包括实例)  
    visitDefault(symbol);  
}

void DependencyVisitor::handle(const slang::ast::InstanceSymbol& symbol) {
    std::cout << "[DEBUG] Processing instance: " << symbol.getHierarchicalPath() << std::endl;
    std::string instanceFile;
    int instanceLine = 0;
    
    const slang::ast::Scope* scope = symbol.getParentScope();
    if (scope) {
        auto& comp = scope->getCompilation();
        auto* sm = comp.getSourceManager();
        if (sm && symbol.location) {
            instanceFile = std::string(sm->getFileName(symbol.location));
            instanceLine = sm->getLineNumber(symbol.location);
        }
    }

    for (auto* portConnection : symbol.getPortConnections()) {
        //遍历每个连接对
        const slang::ast::Symbol& internalPort = portConnection->port;
        std::cout << "[DEBUG] Processing port: " << internalPort.getHierarchicalPath() << std::endl;
        const slang::ast::Expression* externalExpr = portConnection->getExpression();
        
        VariableInfo& internalPortInfo = getOrAddVariable(internalPort);
        
        if (!externalExpr) continue;
        
        DataSignalVisitor externalSignalVisitor;
        externalExpr->visit(externalSignalVisitor);
        //遍历该内部信号连接的外部信号
        for (const auto& externalSignalName : externalSignalVisitor.signals) {
            if(!results.count(externalSignalName)){
                std::cout << "[DEBUG] External signal not found in results for inter signal:" << internalPort.getHierarchicalPath() << std::endl;
                continue;
            }
            if (results.count(externalSignalName)) {
                VariableInfo& externalInfo = results[externalSignalName];
                std::cout << "[DEBUG] Processing conn: " << externalInfo.fullName << "---"<<internalPort.getHierarchicalPath()<<std::endl;
                auto direction = internalPort.as<slang::ast::PortSymbol>().direction;
                
                if (direction != slang::ast::ArgumentDirection::In) { 
                    AssignmentInfo assignInfo;
                    assignInfo.path = pathStack.back();
                    assignInfo.drivingSignals = {internalPortInfo.fullName};
                    assignInfo.file = instanceFile;
                    assignInfo.line = instanceLine;
                    assignInfo.type = "port_connection";
                    assignInfo.logicType = "combinational";
                    assignInfo.conditionDepth = pathStack.size() - 1;
                    externalInfo.assignments.insert(assignInfo);
                    
                    internalPortInfo.fanOut.insert(externalInfo.fullName);
                }
                if (direction != slang::ast::ArgumentDirection::Out) { 
                    AssignmentInfo assignInfo;
                    assignInfo.path = pathStack.back();
                    assignInfo.drivingSignals = std::set<std::string>{externalSignalName};
                    assignInfo.file = instanceFile;
                    assignInfo.line = instanceLine;
                    assignInfo.type = "port_connection";
                    assignInfo.logicType = "combinational";
                    assignInfo.conditionDepth = pathStack.size() - 1;
                    internalPortInfo.assignments.insert(assignInfo);
                    
                    externalInfo.fanOut.insert(internalPortInfo.fullName);
                }
            }
        }
    }

    visitDefault(symbol);
}

void DependencyVisitor::handle(const slang::ast::ProceduralBlockSymbol& symbol) {  
    auto* prevBlock = currentProcBlock;  
    currentProcBlock = &symbol;  
    visitDefault(symbol);  
    currentProcBlock = prevBlock;  
}

// ============================================================================
// 后处理和分析函数
// ============================================================================

bool DependencyVisitor::isControlVariable(const std::string& varName) {
    for (const auto& [otherName, otherInfo] : results) {
        for (const auto& assignment : otherInfo.assignments) {
            for (const auto& clause : assignment.path) {
                if (clause.expr.involvedSignals.count(varName)) {
                    return true;
                }
            }
        }
    }
    return false;
}

void DependencyVisitor::postProcess() {
    // Stage 1: 填充 fanOut 集合
    for (auto& [lhsName, info] : results) {
        for (const auto& assignment : info.assignments) {
            for (const auto& rhsName : assignment.drivingSignals) {
                if (results.count(rhsName)) {
                    results[rhsName].fanOut.insert(lhsName);
                }
            }
        }
    }

    // Stage 2: 清理赋值信息并计算聚合信息
    for (auto& [varName, info] : results) {
        std::set<AssignmentInfo> cleanedAssignments;
        
        for (const auto& assignment : info.assignments) {
            if (assignment.drivingSignals.empty() && 
                assignment.file.empty() && 
                assignment.line == 0) {
                continue;
            }
            if (assignment.type == "direct" && assignment.drivingSignals.empty()) {
                continue;
            }
            cleanedAssignments.insert(assignment);
        }
        
        info.assignments = cleanedAssignments;
        info.assignmentCount = info.assignments.size();
        
        // 计算 drivesOutput
        info.drivesOutput = false;
        for (const auto& fanOutName : info.fanOut) {
            if (results.count(fanOutName) && 
                results[fanOutName].direction == "output") {
                info.drivesOutput = true;
                break;
            }
        }
        
        // 计算 isControlVariable
        info.isControlVariable = isControlVariable(varName);
    }
}#pragma once  
#include "DataModel.h"  
#include "DependencyVisitor.h"  
#include <queue>  
#include <set>  
#include <string>  
#include "json.hpp"  
// 切片粒度级别  
enum class SliceGranularity {  
    Statement,      // 仅赋值语句  
    ControlBlock,   // 包含直接控制结构(if/case)  
    ProceduralBlock,// 完整的always/assign块  
    Module          // 完整模块定义  
};  
  
// 过滤选项  
enum class SliceFilterOptions {  
    None = 0,  
    RemoveUnrelatedAssignments = 1 << 0,  
    RemoveConstantAssignments = 1 << 1,  
    RemoveResetLogic = 1 << 2,  
    KeepControlStructure = 1 << 3,  
    IncludeComments = 1 << 4,  
    IncludeContext = 1 << 5  
};  
  
// 位运算符重载  
inline SliceFilterOptions operator|(SliceFilterOptions a, SliceFilterOptions b) {  
    return static_cast<SliceFilterOptions>(static_cast<int>(a) | static_cast<int>(b));  
}  
  
inline SliceFilterOptions& operator|=(SliceFilterOptions& a, SliceFilterOptions b) {  
    a = a | b;  
    return a;  
}  
  
inline SliceFilterOptions operator&(SliceFilterOptions a, SliceFilterOptions b) {  
    return static_cast<SliceFilterOptions>(static_cast<int>(a) & static_cast<int>(b));  
}  
  
// 辅助函数:检查位标志  
inline bool hasFlag(SliceFilterOptions flags, SliceFilterOptions flag) {  
    return (static_cast<int>(flags) & static_cast<int>(flag)) != 0;  
}  
  
// 切片配置  
struct SliceConfig {  
    SliceGranularity granularity = SliceGranularity::ControlBlock;  
    SliceFilterOptions filterOptions = SliceFilterOptions::RemoveUnrelatedAssignments;  
    int contextLines = 2;  
    bool includeSourceInfo = true;  
    bool includeConditionPaths = true;  
};  
  
// 切片准则  
struct SlicingCriterion {  
    std::string variableName;  
    std::string fileName;  
    int lineNumber = -1;  
};  
  
// 切片结果  
struct SliceResult {  
    std::set<std::string> relevantVariables;  
    std::map<std::string, std::set<AssignmentInfo>> relevantAssignments;  
    std::set<std::string> controlVariables;  
};  

struct CompleteCodeBlock {  
    std::string blockType;  // "always_ff", "always_comb", "assign"  
    std::string sourceCode;  
    std::set<std::string> affectedVariables;  
    std::string file;  
    int startLine;  
    int endLine;  
}; 

class   ProgramSlicer {  
public:  
    explicit ProgramSlicer(const AnalysisResultMap& analysisResults);  
      
    // 后向切片  
    SliceResult backwardSlice(const SlicingCriterion& criterion,  
                             const SliceConfig& config = SliceConfig());  
      
    // 前向切片  
    SliceResult forwardSlice(const SlicingCriterion& criterion,  
                            const SliceConfig& config = SliceConfig());  
    std::vector<CompleteCodeBlock> extractCompleteBlocks(  
                                                        const SliceResult& result,  
                                                        const slang::SourceManager& sourceManager);  
    // 导出为JSON  
    void exportSliceToJson(const SliceResult& result, const std::string& outputPath);  
      
    // 导出包含源代码  
    void exportSliceWithSourceCode(const SliceResult& result,  
                                   const slang::SourceManager& sourceManager,  
                                   const std::string& outputPath,  
                                   const SliceConfig& config = SliceConfig());  
    // 新增:为单个变量生成合并的代码片段  
    std::string generateMergedCodeForVariable(  
        const SliceResult& result,  
        const std::string& targetVariable,  
        const slang::SourceManager& sourceManager);  
      
    // 新增:为所有变量生成合并的代码片段  
    std::map<std::string, std::string> generateAllMergedCode(  
        const std::map<std::string, SliceResult>& allSlices,  
        const slang::SourceManager& sourceManager);  
  
private:  
    const AnalysisResultMap& results;  
      
    // 辅助方法  
    bool matchesCriterion(const std::string& varName,  
                         const AssignmentInfo& assignment,  
                         const SlicingCriterion& criterion);  
      
    std::string extractCodeWithConfig(const AssignmentInfo& assignment,  
                                     const SliceConfig& config,  
                                     const std::set<std::string>& relevantVars);  
      
    std::string extractSourceLine(const std::string& fileName, int lineNumber);  
    std::string extractControlBlock(const std::string& fileName, int lineNumber);  
    std::string extractProceduralBlock(const std::string& fileName, int lineNumber);  
    std::string extractModuleDefinition(const std::string& fileName);  
    std::string extractSourceLines(const std::string& fileName, int startLine, int endLine);  
    std::string filterUnrelatedAssignments(const std::string& code,  
                                          const std::set<std::string>& relevantVars);
    int findProceduralBlockStart(const std::string& fileName, int targetLine); 
    std::string extractModuleInstance(const std::string& fileName, int lineNumber);   
};
inline void to_json(nlohmann::json& j, const CompleteCodeBlock& block) {  
    j = nlohmann::json{  
        {"blockType", block.blockType},  
        {"file", block.file},  
        {"sourceCode", block.sourceCode},  
        {"affectedVariables", block.affectedVariables}  
    };  
}#include "ProgramSlicer.h"  
#include "json.hpp"  
#include <fstream>  
#include <iostream>  
#include <sstream>  
  
using json = nlohmann::json;  
  
ProgramSlicer::ProgramSlicer(const AnalysisResultMap& analysisResults)  
    : results(analysisResults) {}  
  
SliceResult ProgramSlicer::backwardSlice(const SlicingCriterion& criterion,  
                                         const SliceConfig& config) {  
    SliceResult result;  
    std::queue<std::string> worklist;  
    std::set<std::string> visited;  
      
    worklist.push(criterion.variableName);  
    visited.insert(criterion.variableName);  
      
    std::cout << "[INFO] Starting backward slice from: " << criterion.variableName << std::endl;  
      
    while (!worklist.empty()) {  
        std::string currentVar = worklist.front();  
        worklist.pop();  
          
        auto it = results.find(currentVar);  
        if (it == results.end()) {  
            std::cout << "[WARNING] Variable not found: " << currentVar << std::endl;  
            continue;  
        }  
          
        const VariableInfo& varInfo = it->second;  
        result.relevantVariables.insert(currentVar);  
          
        for (const auto& assignment : varInfo.assignments) {  
            if (!matchesCriterion(currentVar, assignment, criterion)) {  
                continue;  
            }  
              
            result.relevantAssignments[currentVar].insert(assignment);  
              
            // 添加数据依赖  
            for (const auto& drivingSignal : assignment.drivingSignals) {  
                if (visited.find(drivingSignal) == visited.end()) {  
                    worklist.push(drivingSignal);  
                    visited.insert(drivingSignal);  
                }  
            }  
              
            // 添加控制依赖  
            for (const auto& clause : assignment.path) {  
                for (const auto& signal : clause.expr.involvedSignals) {  
                    if (visited.find(signal) == visited.end()) {  
                        worklist.push(signal);  
                        visited.insert(signal);  
                        result.controlVariables.insert(signal);  
                    }  
                }  
            }  
        }  
    }  
      
    std::cout << "[INFO] Backward slice complete. Found " << result.relevantVariables.size()  
              << " relevant variables" << std::endl;  
      
    return result;  
}  
  
SliceResult ProgramSlicer::forwardSlice(const SlicingCriterion& criterion,  
                                        const SliceConfig& config) {  
    SliceResult result;  
    std::queue<std::string> worklist;  
    std::set<std::string> visited;  
      
    worklist.push(criterion.variableName);  
    visited.insert(criterion.variableName);  
      
    std::cout << "[INFO] Starting forward slice from: " << criterion.variableName << std::endl;  
      
    while (!worklist.empty()) {  
        std::string currentVar = worklist.front();  
        worklist.pop();  
          
        auto it = results.find(currentVar);  
        if (it == results.end()) {  
            continue;  
        }  
          
        const VariableInfo& varInfo = it->second;  
        result.relevantVariables.insert(currentVar);  
          
        // 添加该变量的所有赋值  
        for (const auto& assignment : varInfo.assignments) {  
            if (matchesCriterion(currentVar, assignment, criterion)) {  
                result.relevantAssignments[currentVar].insert(assignment);  
            }  
        }  
          
        // 前向追踪:找出所有使用该变量的地方  
        for (const auto& fanOutVar : varInfo.fanOut) {  
            if (visited.find(fanOutVar) == visited.end()) {  
                worklist.push(fanOutVar);  
                visited.insert(fanOutVar);  
            }  
        }  
    }  
      
    std::cout << "[INFO] Forward slice complete. Found " << result.relevantVariables.size()  
              << " relevant variables" << std::endl;  
      
    return result;  
}  
  
bool ProgramSlicer::matchesCriterion(const std::string& varName,  
                                     const AssignmentInfo& assignment,  
                                     const SlicingCriterion& criterion) {  
    if (criterion.fileName.empty() && criterion.lineNumber < 0) {  
        return true;  
    }  
      
    if (!criterion.fileName.empty() && assignment.file != criterion.fileName) {  
        return false;  
    }  
      
    if (criterion.lineNumber >= 0 && assignment.line != criterion.lineNumber) {  
        return false;  
    }  
      
    return true;  
}  
  
void ProgramSlicer::exportSliceToJson(const SliceResult& result, const std::string& outputPath) {  
    json j;  
      
    j["relevantVariables"] = result.relevantVariables;  
    j["controlVariables"] = result.controlVariables;  
      
    json assignmentsJson = json::object();  
    for (const auto& [varName, assignments] : result.relevantAssignments) {  
        json varAssignments = json::array();  
        for (const auto& assignment : assignments) {  
            json assignJson;  
            assignJson["file"] = assignment.file;  
            assignJson["line"] = assignment.line;  
            assignJson["type"] = assignment.type;  
            assignJson["logicType"] = assignment.logicType;  
            assignJson["drivingSignals"] = assignment.drivingSignals;  
            assignJson["conditionDepth"] = assignment.conditionDepth;  
              
            json pathJson = json::array();  
            for (const auto& clause : assignment.path) {  
                json clauseJson;  
                clauseJson["expression"] = clause.expr.expression;  
                clauseJson["involvedSignals"] = clause.expr.involvedSignals;  
                clauseJson["polarity"] = clause.polarity;  
                pathJson.push_back(clauseJson);  
            }  
            assignJson["conditionPath"] = pathJson;  
              
            varAssignments.push_back(assignJson);  
        }  
        assignmentsJson[varName] = varAssignments;  
    }  
    j["relevantAssignments"] = assignmentsJson;  
      
    std::ofstream outFile(outputPath);  
    if (outFile.is_open()) {  
        outFile << j.dump(4);  
        outFile.close();  
        std::cout << "[SUCCESS] Slice result written to: " << outputPath << std::endl;  
    } else {  
        std::cerr << "[ERROR] Could not open output file: " << outputPath << std::endl;  
    }  
}  
  
void ProgramSlicer::exportSliceWithSourceCode(const SliceResult& result,  
                                              const slang::SourceManager& sourceManager,  
                                              const std::string& outputPath,  
                                              const SliceConfig& config) {  
    json j;  
      
    j["relevantVariables"] = result.relevantVariables;  
    j["controlVariables"] = result.controlVariables;  
      
    // 提取完整的代码块  
    auto completeBlocks = extractCompleteBlocks(result, sourceManager);  
      
    json blocksJson = json::array();  
    for (const auto& block : completeBlocks) {  
        json blockJson;  
        blockJson["blockType"] = block.blockType;  
        blockJson["file"] = block.file;  
        blockJson["affectedVariables"] = block.affectedVariables;  
        blockJson["sourceCode"] = block.sourceCode;  
        blocksJson.push_back(blockJson);  
    }  
      
    j["completeCodeBlocks"] = blocksJson;  
      
    std::ofstream outFile(outputPath);  
    if (outFile.is_open()) {  
        outFile << j.dump(4);  
        outFile.close();  
    }  
}
  
std::string ProgramSlicer::extractSourceLine(const std::string& fileName, int lineNumber) {  
    std::ifstream file(fileName);  
    if (!file.is_open()) {  
        return "// Error: Could not open file";  
    }  
      
    std::string line;  
    int currentLine = 1;  
    while (std::getline(file, line)) {  
        if (currentLine == lineNumber) {  
            return line;  
        }  
        currentLine++;  
    }  
    return "// Line not found";  
}  
  
std::string ProgramSlicer::extractSourceLines(const std::string& fileName,   
                                              int startLine, int endLine) {  
    std::ifstream file(fileName);  
    if (!file.is_open()) {  
        return "// Error: Could not open file";  
    }  
      
    std::stringstream result;  
    std::string line;  
    int currentLine = 1;  
      
    while (std::getline(file, line)) {  
        if (currentLine >= startLine && currentLine <= endLine) {  
            result << line << "\n";  
        }  
        if (currentLine > endLine) break;  
        currentLine++;  
    }  
      
    return result.str();  
}  
  
std::string ProgramSlicer::extractControlBlock(const std::string& fileName, int lineNumber) {  
    // 简化实现:返回目标行及其上下文  
    return extractSourceLines(fileName, lineNumber - 5, lineNumber + 5);  
}  
  
std::string ProgramSlicer::extractProceduralBlock(const std::string& fileName, int targetLine) {  
    std::ifstream file(fileName);  
    if (!file.is_open()) {  
        return "// Error: Could not open file";  
    }  
      
    std::vector<std::string> lines;  
    std::string line;  
    while (std::getline(file, line)) {  
        lines.push_back(line);  
    }  
      
    if (targetLine < 1 || targetLine > lines.size()) {  
        return "// Line out of range";  
    }  
      
    // 向上查找 always 块的开始  
    int startLine = targetLine - 1;  
    for (int i = targetLine - 1; i >= 0; i--) {  
        std::string& currentLine = lines[i];  
        if (currentLine.find("always_ff") != std::string::npos ||  
            currentLine.find("always_comb") != std::string::npos ||  
            currentLine.find("always @") != std::string::npos ||  
            currentLine.find("always_latch") != std::string::npos) {  
            startLine = i;  
            break;  
        }  
    }  
      
    // 向下查找块的结束(匹配 begin/end)  
    int endLine = targetLine - 1;  
    int depth = 0;  
    bool foundBegin = false;  
      
    for (int i = startLine; i < lines.size(); i++) {  
        std::string& currentLine = lines[i];  
          
        // 计算 begin/end 深度  
        size_t pos = 0;  
        while ((pos = currentLine.find("begin", pos)) != std::string::npos) {  
            depth++;  
            foundBegin = true;  
            pos += 5;  
        }  
          
        pos = 0;  
        while ((pos = currentLine.find("end", pos)) != std::string::npos) {  
            // 确保不是 endmodule 或 endcase  
            if (pos + 3 < currentLine.length()) {  
                char nextChar = currentLine[pos + 3];  
                if (nextChar == ' ' || nextChar == '\n' || nextChar == ';') {  
                    depth--;  
                }  
            }  
            pos += 3;  
        }  
          
        endLine = i;  
          
        if (foundBegin && depth == 0) {  
            break;  
        }  
    }  
      
    // 提取完整块  
    std::stringstream result;  
    for (int i = startLine; i <= endLine; i++) {  
        result << lines[i] << "\n";  
    }  
      
    return result.str();  
}
  
std::string ProgramSlicer::extractModuleDefinition(const std::string& fileName) {  
    std::ifstream file(fileName);  
    if (!file.is_open()) {  
        return "// Error: Could not open file";  
    }  
      
    std::stringstream result;  
    std::string line;  
    while (std::getline(file, line)) {  
        result << line << "\n";  
    }  
      
    return result.str();  
}  
  
std::string ProgramSlicer::filterUnrelatedAssignments(const std::string& code,  
                                                      const std::set<std::string>& relevantVars) {  
    // 简化实现:直接返回原代码  
    // 完整实现需要解析代码并过滤无关赋值  
    return code;  
}  
  
std::string ProgramSlicer::extractCodeWithConfig(const AssignmentInfo& assignment,  
                                                 const SliceConfig& config,  
                                                 const std::set<std::string>& relevantVars) {  
    std::string result;  
      
    switch (config.granularity) {  
        case SliceGranularity::Statement:  
            result = extractSourceLine(assignment.file, assignment.line);  
            break;  
              
        case SliceGranularity::ControlBlock:  
            result = extractControlBlock(assignment.file, assignment.line);  
              
            if (hasFlag(config.filterOptions, SliceFilterOptions::RemoveUnrelatedAssignments)) {  
                result = filterUnrelatedAssignments(result, relevantVars);  
            }  
            break;  
              
        case SliceGranularity::ProceduralBlock:  
            result = extractProceduralBlock(assignment.file, assignment.line);  
              
            if (hasFlag(config.filterOptions, SliceFilterOptions::RemoveUnrelatedAssignments)) {  
                result = filterUnrelatedAssignments(result, relevantVars);  
            }  
            break;  
              
        case SliceGranularity::Module:  
            result = extractModuleDefinition(assignment.file);  
            break;  
    }  
      
    // 添加上下文行  
    if (hasFlag(config.filterOptions, SliceFilterOptions::IncludeContext)) {  
        std::string context = extractSourceLines(  
            assignment.file,  
            assignment.line - config.contextLines,  
            assignment.line + config.contextLines  
        );  
        result = "// Context:\n" + context + "\n// Extracted:\n" + result;  
    }  
      
    return result;  
}

 
  
std::vector<CompleteCodeBlock> ProgramSlicer::extractCompleteBlocks(  
    const SliceResult& result,  
    const slang::SourceManager& sourceManager) {  
      
    std::map<std::string, CompleteCodeBlock> uniqueBlocks;  
    std::vector<CompleteCodeBlock> blocks;  
    std::set<std::string> processedAssigns;  
      
    for (const auto& [varName, assignments] : result.relevantAssignments) {  
        for (const auto& assignment : assignments) {  
            std::string blockKey;  
            std::string blockType;  
            std::string blockCode;  
              
            // 判断赋值类型并提取相应的代码块  
            if (assignment.type == "port_connection") {  
                // 模块实例化  
                blockKey = assignment.file + ":instance:" + std::to_string(assignment.line);  
                blockType = "module_instance";  
                blockCode = extractModuleInstance(assignment.file, assignment.line);  
            }  
            else if (assignment.logicType == "sequential" || assignment.logicType == "combinational") {  
                if (assignment.conditionDepth > 0 || !assignment.path.empty()) {  
                    // 过程块 (always)  
                    int blockStartLine = findProceduralBlockStart(assignment.file, assignment.line);  
                    blockKey = assignment.file + ":procedural:" + std::to_string(blockStartLine);  
                    blockType = (assignment.logicType == "sequential") ? "always" : "always";  
                    blockCode = extractProceduralBlock(assignment.file, assignment.line);  
                }  
                else {  
                    // 连续赋值 (assign)  
                    blockKey = assignment.file + ":assign:" + std::to_string(assignment.line);  
                    blockType = "assign";  
                    blockCode = extractSourceLine(assignment.file, assignment.line);  
                }  
            }  
            else {  
                // 默认处理  
                blockKey = assignment.file + ":" + std::to_string(assignment.line);  
                blockType = "unknown";  
                blockCode = extractSourceLine(assignment.file, assignment.line);  
            }  
              
            // 去重并添加到uniqueBlocks  
            if (uniqueBlocks.find(blockKey) == uniqueBlocks.end()) {  
                CompleteCodeBlock block;  
                block.file = assignment.file;  
                block.blockType = blockType;  
                block.sourceCode = blockCode;  
                uniqueBlocks[blockKey] = block;  
            }  
              
            uniqueBlocks[blockKey].affectedVariables.insert(varName);  
        }  
    }  
      
    // 转换为vector  
    for (const auto& [key, block] : uniqueBlocks) {  
        blocks.push_back(block);  
    }  
      
    return blocks;  
}
std::string ProgramSlicer::extractModuleInstance(const std::string& fileName, int targetLine) {  
    std::ifstream file(fileName);  
    if (!file.is_open()) {  
        return "// Error: Could not open file";  
    }  
      
    std::vector<std::string> lines;  
    std::string line;  
    while (std::getline(file, line)) {  
        lines.push_back(line);  
    }  
    file.close();  
      
    if (targetLine < 1 || targetLine > lines.size()) {  
        return "// Error: Invalid line number";  
    }  
      
    int startLine = targetLine - 1;  
    int endLine = targetLine - 1;  
      
    // 向上查找模块实例化的开始(模块名)  
    for (int i = targetLine - 1; i >= 0; i--) {  
        std::string trimmed = lines[i];  
        // 移除前导空白  
        size_t firstNonSpace = trimmed.find_first_not_of(" \t");  
        if (firstNonSpace != std::string::npos) {  
            trimmed = trimmed.substr(firstNonSpace);  
        }  
          
        // 检查是否是模块实例化的开始  
        // Verilog模块实例化格式: module_name instance_name (  
        if (trimmed.find('(') != std::string::npos &&   
            trimmed.find("module") == std::string::npos &&  
            trimmed.find("endmodule") == std::string::npos) {  
            startLine = i;  
            break;  
        }  
          
        // 如果遇到分号或其他语句结束标记,停止  
        if (trimmed.find(';') != std::string::npos) {  
            break;  
        }  
    }  
      
    // 向下查找模块实例化的结束(分号)  
    for (int i = targetLine - 1; i < lines.size(); i++) {  
        if (lines[i].find(");") != std::string::npos) {  
            endLine = i;  
            break;  
        }  
    }  
      
    // 提取完整的模块实例化语句  
    std::stringstream result;  
    for (int i = startLine; i <= endLine; i++) {  
        result << lines[i];  
        if (i < endLine) {  
            result << "\n";  
        }  
    }  
      
    return result.str();  
}

// 新增辅助方法:找到过程块的起始行号  
int ProgramSlicer::findProceduralBlockStart(const std::string& fileName, int targetLine) {  
    std::ifstream file(fileName);  
    if (!file.is_open()) {  
        return targetLine;  
    }  
      
    std::vector<std::string> lines;  
    std::string line;  
    while (std::getline(file, line)) {  
        lines.push_back(line);  
    }  
      
    if (targetLine < 1 || targetLine > lines.size()) {  
        return targetLine;  
    }  
      
    // 向上查找 always 块的开始  
    for (int i = targetLine - 1; i >= 0; i--) {  
        const std::string& currentLine = lines[i];  
        if (currentLine.find("always_ff") != std::string::npos ||  
            currentLine.find("always_comb") != std::string::npos ||  
            currentLine.find("always @") != std::string::npos ||  
            currentLine.find("always_latch") != std::string::npos) {  
            return i + 1;  // 返回1-based行号  
        }  
    }  
      
    return targetLine;  
}

std::string ProgramSlicer::generateMergedCodeForVariable(  
    const SliceResult& result,  
    const std::string& targetVariable,  
    const slang::SourceManager& sourceManager) {  
      
    std::stringstream mergedCode;  
      
    // 1. 添加模块头部注释  
    mergedCode << "// ========================================\n";  
    mergedCode << "// Program Slice for: " << targetVariable << "\n";  
    mergedCode << "// ========================================\n\n";  
      
    // 2. 提取模块名称(从变量名中提取)  
    std::string moduleName = targetVariable.substr(0, targetVariable.find('.'));  
      
    // 3. 收集所有需要的信号声明  
    std::set<std::string> requiredSignals;  
    std::set<std::string> inputSignals;  
    std::set<std::string> outputSignals;  
    std::set<std::string> internalSignals;  
      
    for (const auto& var : result.relevantVariables) {  
        // 从完整路径中提取信号名  
        size_t lastDot = var.find_last_of('.');  
        if (lastDot != std::string::npos) {  
            std::string signalName = var.substr(lastDot + 1);  
            requiredSignals.insert(signalName);  
              
            // 从analysisResults中获取信号的方向信息  
            auto it = results.find(var);  
            if (it != results.end()) {  
                if (it->second.direction == "input") {  
                    inputSignals.insert(signalName);  
                } else if (it->second.direction == "output") {  
                    outputSignals.insert(signalName);  
                } else {  
                    internalSignals.insert(signalName);  
                }  
            }  
        }  
    }  
      
    // 4. 生成模块声明  
    mergedCode << "module " << moduleName << "_sliced(\n";  
      
    // 输入端口  
    bool firstPort = true;  
    for (const auto& signal : inputSignals) {  
        if (!firstPort) mergedCode << ",\n";  
        mergedCode << "    input logic " << signal;  
        firstPort = false;  
    }  
      
    // 输出端口  
    for (const auto& signal : outputSignals) {  
        if (!firstPort) mergedCode << ",\n";  
        mergedCode << "    output logic " << signal;  
        firstPort = false;  
    }  
      
    mergedCode << "\n);\n\n";  
      
    // 5. 内部信号声明  
    if (!internalSignals.empty()) {  
        mergedCode << "    // Internal signals\n";  
        for (const auto& signal : internalSignals) {  
            mergedCode << "    logic " << signal << ";\n";  
        }  
        mergedCode << "\n";  
    }  
      
    // 6. 按类型组织代码块  
    std::vector<CompleteCodeBlock> blocks = extractCompleteBlocks(result, sourceManager);  
      
    // 分类代码块  
    std::vector<CompleteCodeBlock> alwaysFFBlocks;  
    std::vector<CompleteCodeBlock> alwaysCombBlocks;  
    std::vector<CompleteCodeBlock> assignBlocks;  
    std::vector<CompleteCodeBlock> instanceBlocks;  
      
    for (const auto& block : blocks) {  
        if (block.blockType == "always_ff") {  
            alwaysFFBlocks.push_back(block);  
        } else if (block.blockType == "always_comb") {  
            alwaysCombBlocks.push_back(block);  
        } else if (block.blockType == "assign") {  
            assignBlocks.push_back(block);  
        } else if (block.blockType == "module_instance") {  
            instanceBlocks.push_back(block);  
        }  
    }  
      
    // 7. 输出always_ff块  
    if (!alwaysFFBlocks.empty()) {  
        mergedCode << "    // Sequential logic\n";  
        for (const auto& block : alwaysFFBlocks) {  
            mergedCode << block.sourceCode << "\n";  
        }  
        mergedCode << "\n";  
    }  
      
    // 8. 输出always_comb块  
    if (!alwaysCombBlocks.empty()) {  
        mergedCode << "    // Combinational logic\n";  
        for (const auto& block : alwaysCombBlocks) {  
            mergedCode << block.sourceCode << "\n";  
        }  
        mergedCode << "\n";  
    }  
      
    // 9. 输出assign语句  
    if (!assignBlocks.empty()) {  
        mergedCode << "    // Continuous assignments\n";  
        for (const auto& block : assignBlocks) {  
            mergedCode << block.sourceCode << "\n";  
        }  
        mergedCode << "\n";  
    }  
      
    // 10. 输出模块实例化  
    if (!instanceBlocks.empty()) {  
        mergedCode << "    // Module instances\n";  
        for (const auto& block : instanceBlocks) {  
            mergedCode << block.sourceCode << "\n";  
        }  
        mergedCode << "\n";  
    }  
      
    mergedCode << "endmodule\n";  
      
    return mergedCode.str();  
}  
  
std::map<std::string, std::string> ProgramSlicer::generateAllMergedCode(  
    const std::map<std::string, SliceResult>& allSlices,  
    const slang::SourceManager& sourceManager) {  
      
    std::map<std::string, std::string> mergedCodeMap;  
      
    for (const auto& [varName, sliceResult] : allSlices) {  
        std::string mergedCode = generateMergedCodeForVariable(  
            sliceResult, varName, sourceManager);  
        mergedCodeMap[varName] = mergedCode;  
    }  
      
    return mergedCodeMap;  
}